/**
 * @file system_config.c
 * @brief System Configuration Manager Implementation
 * 
 * This file implements the system configuration management functionality.
 * It provides centralized configuration with menuconfig integration,
 * validation, and runtime management capabilities.
 * 
 * @author Learning ESP-IDF
 * @date 2025
 * @version 1.0
 */

#include "system_config.h"
#include "esp_log.h"
#include "sdkconfig.h"
#include <string.h>
#include <stdlib.h>

// Component tag for logging
static const char *TAG = "SYS_CFG";

// Configuration version for compatibility checking
#define CONFIG_VERSION 0x20250001

// Maximum number of registered callbacks
#define MAX_CONFIG_CALLBACKS 8

/**
 * @brief Configuration change callback entry structure
 * 
 * Internal structure to store registered callback information
 */
typedef struct {
    config_change_callback_t callback;  /**< Callback function pointer */
    void *user_data;                    /**< User data for callback */
    bool active;                        /**< Callback is active flag */
} config_callback_entry_t;

// Global configuration instance
static system_config_t g_system_config = {0};

// Callback management
static config_callback_entry_t g_config_callbacks[MAX_CONFIG_CALLBACKS] = {0};
static bool g_config_initialized = false;

/**
 * @brief Load GPIO configuration from menuconfig
 * 
 * Loads all GPIO pin assignments from the ESP-IDF configuration system
 * and populates the GPIO configuration structure. This function reads the
 * CONFIG_* macros generated by the menuconfig system from Kconfig.projbuild.
 * 
 * @param gpio_config Pointer to GPIO configuration structure to populate
 */
static void load_gpio_config(system_gpio_config_t *gpio_config) {
    // LED GPIO configuration from menuconfig
    gpio_config->led_pin = (gpio_num_t)CONFIG_LED_GPIO_PIN;
    gpio_config->led_active_level = CONFIG_LED_ACTIVE_LEVEL ? 1 : 0;
    
    // Button GPIO configuration from menuconfig
    gpio_config->button_pin = (gpio_num_t)CONFIG_BUTTON_GPIO_PIN;
    gpio_config->button_active_level = CONFIG_BUTTON_ACTIVE_LEVEL ? 1 : 0;
    
    // DHT22 sensor GPIO configuration from menuconfig
    gpio_config->dht22_pin = (gpio_num_t)CONFIG_DHT22_GPIO_PIN;
    
    // MPU6050 I2C GPIO configuration from menuconfig
    gpio_config->mpu6050_sda_pin = (gpio_num_t)CONFIG_MPU6050_I2C_SDA_PIN;
    gpio_config->mpu6050_scl_pin = (gpio_num_t)CONFIG_MPU6050_I2C_SCL_PIN;
    
    // SD card SPI GPIO configuration from menuconfig
    gpio_config->sd_cs_pin = (gpio_num_t)CONFIG_SD_CARD_SPI_CS_PIN;
    gpio_config->sd_mosi_pin = (gpio_num_t)CONFIG_SD_CARD_SPI_MOSI_PIN;
    gpio_config->sd_miso_pin = (gpio_num_t)CONFIG_SD_CARD_SPI_MISO_PIN;
    gpio_config->sd_clk_pin = (gpio_num_t)CONFIG_SD_CARD_SPI_CLK_PIN;
    
    ESP_LOGD(TAG, "GPIO configuration loaded from menuconfig");
    ESP_LOGD(TAG, "LED: GPIO%d (active %s), Button: GPIO%d (active %s)", 
             gpio_config->led_pin, gpio_config->led_active_level ? "HIGH" : "LOW",
             gpio_config->button_pin, gpio_config->button_active_level ? "HIGH" : "LOW");
    ESP_LOGD(TAG, "DHT22: GPIO%d, MPU6050: SDA=GPIO%d SCL=GPIO%d", 
             gpio_config->dht22_pin, gpio_config->mpu6050_sda_pin, gpio_config->mpu6050_scl_pin);
}

/**
 * @brief Load timing configuration from menuconfig
 * 
 * Loads all timing parameters from the ESP-IDF configuration system
 * and populates the timing configuration structure. This function reads the
 * CONFIG_* macros generated by the menuconfig system from Kconfig.projbuild.
 * 
 * @param timing_config Pointer to timing configuration structure to populate
 */
static void load_timing_config(system_timing_config_t *timing_config) {
    // Button timing configuration from menuconfig
    timing_config->button_debounce_ms = CONFIG_BUTTON_DEBOUNCE_TIME_MS;
    timing_config->button_long_press_ms = CONFIG_BUTTON_LONG_PRESS_TIME_MS;
    timing_config->button_double_click_ms = CONFIG_BUTTON_DOUBLE_CLICK_TIMEOUT_MS;
    
    // Application timing configuration from menuconfig
    timing_config->sensor_read_interval_ms = CONFIG_SENSOR_READ_INTERVAL_MS;
    timing_config->data_log_interval_ms = CONFIG_DATA_LOG_INTERVAL_MS;
    timing_config->mqtt_publish_interval_ms = CONFIG_MQTT_PUBLISH_INTERVAL_MS;
    
    ESP_LOGD(TAG, "Timing configuration loaded from menuconfig");
    ESP_LOGD(TAG, "Button: debounce=%lums, long_press=%lums, double_click=%lums", 
             timing_config->button_debounce_ms, timing_config->button_long_press_ms, 
             timing_config->button_double_click_ms);
    ESP_LOGD(TAG, "Intervals: sensor=%lums, log=%lums, mqtt=%lums", 
             timing_config->sensor_read_interval_ms, timing_config->data_log_interval_ms,
             timing_config->mqtt_publish_interval_ms);
}

/**
 * @brief Load network configuration from menuconfig
 * 
 * Loads all network-related parameters from the ESP-IDF configuration system
 * and populates the network configuration structure. This function reads the
 * CONFIG_* macros generated by the menuconfig system from Kconfig.projbuild.
 * 
 * @param network_config Pointer to network configuration structure to populate
 */
static void load_network_config(system_network_config_t *network_config) {
    // WiFi configuration from menuconfig - copy strings safely
    strncpy(network_config->wifi_ssid, CONFIG_WIFI_SSID, sizeof(network_config->wifi_ssid) - 1);
    network_config->wifi_ssid[sizeof(network_config->wifi_ssid) - 1] = '\0';
    
    strncpy(network_config->wifi_password, CONFIG_WIFI_PASSWORD, sizeof(network_config->wifi_password) - 1);
    network_config->wifi_password[sizeof(network_config->wifi_password) - 1] = '\0';
    
    // MQTT configuration from menuconfig - copy strings safely
    strncpy(network_config->mqtt_broker_uri, CONFIG_MQTT_BROKER_URI, sizeof(network_config->mqtt_broker_uri) - 1);
    network_config->mqtt_broker_uri[sizeof(network_config->mqtt_broker_uri) - 1] = '\0';
    
    strncpy(network_config->mqtt_topic_prefix, CONFIG_MQTT_TOPIC_PREFIX, sizeof(network_config->mqtt_topic_prefix) - 1);
    network_config->mqtt_topic_prefix[sizeof(network_config->mqtt_topic_prefix) - 1] = '\0';
    
    // Set default MQTT port (can be extended with menuconfig option later)
    network_config->mqtt_port = 1883;
    network_config->mqtt_use_tls = false;
    
    ESP_LOGD(TAG, "Network configuration loaded from menuconfig");
    ESP_LOGD(TAG, "WiFi SSID: %s", network_config->wifi_ssid);
    ESP_LOGD(TAG, "MQTT Broker: %s", network_config->mqtt_broker_uri);
    ESP_LOGD(TAG, "MQTT Topic Prefix: %s", network_config->mqtt_topic_prefix);
}

/**
 * @brief Check for GPIO pin conflicts
 * 
 * Validates that no two functions are assigned to the same GPIO pin
 * and that all pin assignments are unique.
 * 
 * @param gpio_config Pointer to GPIO configuration to validate
 * @return CONFIG_VALID if no conflicts, CONFIG_INVALID_COMBINATION if conflicts found
 */
static config_validation_result_t validate_gpio_conflicts(const system_gpio_config_t *gpio_config) {
    // Array to track which pins are used
    bool pin_used[GPIO_NUM_MAX] = {false};
    
    // Check each pin assignment for conflicts
    gpio_num_t pins_to_check[] = {
        gpio_config->led_pin,
        gpio_config->button_pin,
        gpio_config->dht22_pin,
        gpio_config->mpu6050_sda_pin,
        gpio_config->mpu6050_scl_pin,
        gpio_config->sd_cs_pin,
        gpio_config->sd_mosi_pin,
        gpio_config->sd_miso_pin,
        gpio_config->sd_clk_pin
    };
    
    const char* pin_names[] = {
        "LED", "Button", "DHT22", "MPU6050_SDA", "MPU6050_SCL",
        "SD_CS", "SD_MOSI", "SD_MISO", "SD_CLK"
    };
    
    size_t num_pins = sizeof(pins_to_check) / sizeof(pins_to_check[0]);
    
    // Check for duplicate pin assignments
    for (size_t i = 0; i < num_pins; i++) {
        gpio_num_t pin = pins_to_check[i];
        
        // Validate pin number range
        if (pin < 0 || pin >= GPIO_NUM_MAX) {
            ESP_LOGE(TAG, "Invalid GPIO pin %d for %s", pin, pin_names[i]);
            return CONFIG_INVALID_GPIO;
        }
        
        // Check for conflict with previously assigned pins
        if (pin_used[pin]) {
            ESP_LOGE(TAG, "GPIO pin %d conflict: already assigned (current assignment: %s)", pin, pin_names[i]);
            return CONFIG_INVALID_COMBINATION;
        }
        
        // Mark pin as used
        pin_used[pin] = true;
    }
    
    ESP_LOGD(TAG, "GPIO pin conflict validation passed");
    return CONFIG_VALID;
}

/**
 * @brief Notify all registered callbacks of configuration change
 * 
 * Calls all registered configuration change callbacks with the current
 * configuration. Used when configuration is updated or reloaded.
 */
static void notify_config_callbacks(void) {
    // Call all active registered callbacks
    for (int i = 0; i < MAX_CONFIG_CALLBACKS; i++) {
        if (g_config_callbacks[i].active && g_config_callbacks[i].callback != NULL) {
            ESP_LOGD(TAG, "Calling configuration callback %d", i);
            g_config_callbacks[i].callback(&g_system_config, g_config_callbacks[i].user_data);
        }
    }
}

// Public API Implementation

esp_err_t system_config_init(void) {
    ESP_LOGI(TAG, "Initializing system configuration manager");
    
    // Clear configuration structure
    memset(&g_system_config, 0, sizeof(g_system_config));
    
    // Set configuration version
    g_system_config.config_version = CONFIG_VERSION;
    
    // Load configuration from menuconfig
    load_gpio_config(&g_system_config.gpio);
    load_timing_config(&g_system_config.timing);
    load_network_config(&g_system_config.network);
    
    // Mark configuration as initialized BEFORE validation
    g_system_config.initialized = true;
    g_config_initialized = true;
    
    // Validate loaded configuration
    config_validation_result_t validation_result = system_config_validate_all();
    if (validation_result != CONFIG_VALID) {
        ESP_LOGE(TAG, "Configuration validation failed: %s", 
                 system_config_validation_to_string(validation_result));
        // Reset initialization flags on failure
        g_system_config.initialized = false;
        g_config_initialized = false;
        return ESP_ERR_INVALID_ARG;
    }
    
    // Initialize callback array
    memset(g_config_callbacks, 0, sizeof(g_config_callbacks));
    
    ESP_LOGI(TAG, "System configuration initialized successfully");
    ESP_LOGI(TAG, "Configuration version: 0x%08lX", g_system_config.config_version);
    
    // Print initial configuration for verification
    system_config_print(false);
    
    return ESP_OK;
}

const system_config_t* system_config_get(void) {
    if (!g_config_initialized) {
        ESP_LOGE(TAG, "Configuration system not initialized");
        return NULL;
    }
    
    return &g_system_config;
}

const system_gpio_config_t* system_config_get_gpio(void) {
    const system_config_t *config = system_config_get();
    return config ? &config->gpio : NULL;
}

const system_timing_config_t* system_config_get_timing(void) {
    const system_config_t *config = system_config_get();
    return config ? &config->timing : NULL;
}

const system_network_config_t* system_config_get_network(void) {
    const system_config_t *config = system_config_get();
    return config ? &config->network : NULL;
}

config_validation_result_t system_config_validate_gpio(gpio_num_t pin, bool is_input, bool allow_internal) {
    // Check basic pin number validity
    if (pin < 0 || pin >= GPIO_NUM_MAX) {
        return CONFIG_INVALID_GPIO;
    }
    
    // Check if pin is valid for the intended use
    if (is_input) {
        if (!GPIO_IS_VALID_GPIO(pin)) {
            return CONFIG_INVALID_GPIO;
        }
    } else {
        if (!GPIO_IS_VALID_OUTPUT_GPIO(pin)) {
            return CONFIG_INVALID_GPIO;
        }
    }
    
    // Check for restricted pins (unless internal use is allowed)
    if (!allow_internal) {
        // GPIO 6-11 are typically connected to flash on most ESP32 modules
        if (pin >= 6 && pin <= 11) {
            return CONFIG_INVALID_GPIO;
        }
        
        // GPIO 34-39 are input-only on ESP32
        if (!is_input && pin >= 34 && pin <= 39) {
            return CONFIG_INVALID_GPIO;
        }
    }
    
    return CONFIG_VALID;
}

config_validation_result_t system_config_validate_timing(uint32_t value, uint32_t min_value, uint32_t max_value) {
    if (value < min_value || value > max_value) {
        return CONFIG_INVALID_RANGE;
    }
    return CONFIG_VALID;
}

config_validation_result_t system_config_validate_all(void) {
    if (!g_config_initialized) {
        return CONFIG_NOT_INITIALIZED;
    }
    
    // Validate GPIO configuration
    config_validation_result_t result = validate_gpio_conflicts(&g_system_config.gpio);
    if (result != CONFIG_VALID) {
        ESP_LOGE(TAG, "GPIO configuration validation failed");
        return result;
    }
    
    // Validate individual GPIO pins
    if ((result = system_config_validate_gpio(g_system_config.gpio.led_pin, false, false)) != CONFIG_VALID) {
        ESP_LOGE(TAG, "LED GPIO validation failed");
        return result;
    }
    
    if ((result = system_config_validate_gpio(g_system_config.gpio.button_pin, true, false)) != CONFIG_VALID) {
        ESP_LOGE(TAG, "Button GPIO validation failed");
        return result;
    }
    
    // Validate timing parameters
    if ((result = system_config_validate_timing(g_system_config.timing.button_debounce_ms, 10, 500)) != CONFIG_VALID) {
        ESP_LOGE(TAG, "Button debounce timing validation failed");
        return result;
    }
    
    if ((result = system_config_validate_timing(g_system_config.timing.button_long_press_ms, 500, 5000)) != CONFIG_VALID) {
        ESP_LOGE(TAG, "Button long press timing validation failed");
        return result;
    }
    
    if ((result = system_config_validate_timing(g_system_config.timing.sensor_read_interval_ms, 1000, 300000)) != CONFIG_VALID) {
        ESP_LOGE(TAG, "Sensor read interval validation failed");
        return result;
    }
    
    ESP_LOGD(TAG, "Complete configuration validation passed");
    return CONFIG_VALID;
}

esp_err_t system_config_register_callback(config_change_callback_t callback, void *user_data) {
    if (!g_config_initialized) {
        ESP_LOGE(TAG, "Configuration system not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    if (callback == NULL) {
        ESP_LOGE(TAG, "Callback function cannot be NULL");
        return ESP_ERR_INVALID_ARG;
    }
    
    // Find available callback slot
    for (int i = 0; i < MAX_CONFIG_CALLBACKS; i++) {
        if (!g_config_callbacks[i].active) {
            g_config_callbacks[i].callback = callback;
            g_config_callbacks[i].user_data = user_data;
            g_config_callbacks[i].active = true;
            
            ESP_LOGI(TAG, "Configuration callback registered in slot %d", i);
            return ESP_OK;
        }
    }
    
    ESP_LOGE(TAG, "Maximum number of configuration callbacks reached");
    return ESP_ERR_NO_MEM;
}

esp_err_t system_config_reload(void) {
    if (!g_config_initialized) {
        ESP_LOGE(TAG, "Configuration system not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    ESP_LOGI(TAG, "Reloading configuration from menuconfig");
    
    // Save old configuration for comparison
    system_config_t old_config = g_system_config;
    
    // Reload configuration from menuconfig
    load_gpio_config(&g_system_config.gpio);
    load_timing_config(&g_system_config.timing);
    load_network_config(&g_system_config.network);
    
    // Validate new configuration
    config_validation_result_t validation_result = system_config_validate_all();
    if (validation_result != CONFIG_VALID) {
        ESP_LOGE(TAG, "New configuration validation failed, restoring old configuration");
        g_system_config = old_config;
        return ESP_ERR_INVALID_ARG;
    }
    
    // Notify callbacks of configuration change
    notify_config_callbacks();
    
    ESP_LOGI(TAG, "Configuration reloaded successfully");
    return ESP_OK;
}

esp_err_t system_config_reset_to_defaults(void) {
    ESP_LOGI(TAG, "Resetting configuration to defaults");
    
    // Clear current configuration
    g_config_initialized = false;
    
    // Reinitialize with default values
    return system_config_init();
}

void system_config_print(bool show_sensitive) {
    if (!g_config_initialized) {
        ESP_LOGW(TAG, "Configuration system not initialized");
        return;
    }
    
    ESP_LOGI(TAG, "=== System Configuration ===");
    ESP_LOGI(TAG, "Version: 0x%08lX", g_system_config.config_version);
    
    // GPIO Configuration
    ESP_LOGI(TAG, "GPIO Configuration:");
    ESP_LOGI(TAG, "  LED Pin: %d (Active %s)", g_system_config.gpio.led_pin, 
             g_system_config.gpio.led_active_level ? "HIGH" : "LOW");
    ESP_LOGI(TAG, "  Button Pin: %d (Active %s)", g_system_config.gpio.button_pin,
             g_system_config.gpio.button_active_level ? "HIGH" : "LOW");
    ESP_LOGI(TAG, "  DHT22 Pin: %d", g_system_config.gpio.dht22_pin);
    ESP_LOGI(TAG, "  MPU6050 I2C: SDA=%d, SCL=%d", g_system_config.gpio.mpu6050_sda_pin, g_system_config.gpio.mpu6050_scl_pin);
    ESP_LOGI(TAG, "  SD Card SPI: CS=%d, MOSI=%d, MISO=%d, CLK=%d", 
             g_system_config.gpio.sd_cs_pin, g_system_config.gpio.sd_mosi_pin,
             g_system_config.gpio.sd_miso_pin, g_system_config.gpio.sd_clk_pin);
    
    // Timing Configuration
    ESP_LOGI(TAG, "Timing Configuration:");
    ESP_LOGI(TAG, "  Button Debounce: %lu ms", g_system_config.timing.button_debounce_ms);
    ESP_LOGI(TAG, "  Button Long Press: %lu ms", g_system_config.timing.button_long_press_ms);
    ESP_LOGI(TAG, "  Button Double Click: %lu ms", g_system_config.timing.button_double_click_ms);
    ESP_LOGI(TAG, "  Sensor Read Interval: %lu ms", g_system_config.timing.sensor_read_interval_ms);
    ESP_LOGI(TAG, "  Data Log Interval: %lu ms", g_system_config.timing.data_log_interval_ms);
    ESP_LOGI(TAG, "  MQTT Publish Interval: %lu ms", g_system_config.timing.mqtt_publish_interval_ms);
    
    // Network Configuration
    ESP_LOGI(TAG, "Network Configuration:");
    ESP_LOGI(TAG, "  WiFi SSID: %s", g_system_config.network.wifi_ssid);
    if (show_sensitive) {
        ESP_LOGI(TAG, "  WiFi Password: %s", g_system_config.network.wifi_password);
    } else {
        ESP_LOGI(TAG, "  WiFi Password: ****");
    }
    ESP_LOGI(TAG, "  MQTT Broker: %s:%d", g_system_config.network.mqtt_broker_uri, g_system_config.network.mqtt_port);
    ESP_LOGI(TAG, "  MQTT Topic Prefix: %s", g_system_config.network.mqtt_topic_prefix);
    ESP_LOGI(TAG, "  MQTT TLS: %s", g_system_config.network.mqtt_use_tls ? "Enabled" : "Disabled");
    
    ESP_LOGI(TAG, "============================");
}

const char* system_config_validation_to_string(config_validation_result_t result) {
    switch (result) {
        case CONFIG_VALID:              return "Configuration is valid";
        case CONFIG_INVALID_RANGE:      return "Parameter is outside valid range";
        case CONFIG_INVALID_GPIO:       return "GPIO pin is invalid or unavailable";
        case CONFIG_INVALID_COMBINATION: return "Parameter combination is invalid";
        case CONFIG_NOT_INITIALIZED:    return "Configuration system not initialized";
        default:                        return "Unknown validation result";
    }
}

esp_err_t system_config_deinit(void) {
    if (!g_config_initialized) {
        ESP_LOGW(TAG, "Configuration system already deinitialized");
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "Deinitializing system configuration manager");
    
    // Clear all callback registrations
    memset(g_config_callbacks, 0, sizeof(g_config_callbacks));
    
    // Clear configuration data
    memset(&g_system_config, 0, sizeof(g_system_config));
    
    // Mark as not initialized
    g_config_initialized = false;
    
    ESP_LOGI(TAG, "System configuration manager deinitialized");
    return ESP_OK;
}